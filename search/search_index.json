{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the NCS Engineering Playbook","text":"<p>This playbook is your comprehensive guide to engineering best practices, standards, and resources at NCS. Here you'll find:</p> <ul> <li>Proven workflows and processes</li> <li>Coding standards and guidelines</li> <li>Architecture patterns</li> <li>Tools and templates</li> <li>Onboarding resources</li> <li>And much more!</li> </ul> <p>Whether you're new to NCS or a seasoned engineer, this playbook is designed to help you deliver high-quality solutions efficiently and collaboratively.</p> <p>Explore the sections to get started, and welcome to the team!</p>"},{"location":"engineering-basic-checklist/","title":"Engineering Basic Checklist","text":"<p>Use this checklist to ensure your project meets NCS Engineering Fundamentals and industry best practices.</p>"},{"location":"engineering-basic-checklist/#1-source-control","title":"1. Source Control","text":"<ul> <li> Default target branch (e.g., <code>main</code>) is protected/locked.</li> <li> All merges are performed via Pull Requests (PRs).</li> <li> PRs reference related work items (e.g., Jira tickets).</li> <li> Commit messages are clear and consistent (describe what and why).</li> <li> Branch naming follows conventions (see branching).</li> <li> Repository structure is documented.</li> <li> No secrets in commit history or public code (see secret scanning).</li> <li> Follows Git Flow or GitHub Flow as appropriate.</li> </ul>"},{"location":"engineering-basic-checklist/#2-work-item-tracking","title":"2. Work Item Tracking","text":"<ul> <li> All work is tracked in Jira (or equivalent system).</li> </ul>"},{"location":"engineering-basic-checklist/#3-testing","title":"3. Testing","text":"<ul> <li> Unit tests cover all critical components (&gt;90% if possible).</li> <li> Integration/end-to-end tests are implemented and run regularly.</li> <li> Test results are visible and actionable.</li> <li> See testing guide.</li> </ul>"},{"location":"engineering-basic-checklist/#4-cicd","title":"4. CI/CD","text":"<ul> <li> CI runs automated build and tests on every PR.</li> <li> CD deploys to a replica/staging environment before merging to main.</li> <li> Main branch is always shippable.</li> <li> See CI and CD docs.</li> </ul>"},{"location":"engineering-basic-checklist/#5-security","title":"5. Security","text":"<ul> <li> Access is granted on a least-privilege basis.</li> <li> Secrets are stored securely (never in code).</li> <li> Data is encrypted in transit (and at rest, if required).</li> <li> Passwords are hashed and never stored in plain text.</li> <li> System is logically segmented for security (separation of concerns).</li> <li> See security guide.</li> </ul>"},{"location":"engineering-basic-checklist/#6-agilescrum","title":"6. Agile/Scrum","text":"<ul> <li> Daily standups are run by a Process Lead (fixed or rotating).</li> <li> Agile process is clearly defined and documented.</li> <li> Dev Lead, PO, and others manage and refine the backlog.</li> <li> Working agreement is established with the customer.</li> </ul>"},{"location":"engineering-basic-checklist/#7-design-reviews","title":"7. Design Reviews","text":"<ul> <li> Design review process is included in the Working Agreement.</li> <li> Major components are reviewed and alternatives documented.</li> <li> Stories/PRs link to design documents.</li> <li> Each user story includes a design review task (assigned/removed during sprint planning).</li> <li> Project advisors are invited to design reviews or provide feedback.</li> <li> Customer-required reviews are identified and planned.</li> <li> Non-functional requirements are documented.</li> <li> Risks and opportunities are logged.</li> </ul>"},{"location":"engineering-basic-checklist/#8-code-reviews","title":"8. Code Reviews","text":"<ul> <li> Team agrees on the purpose and process of code reviews.</li> <li> Code review checklist or process is established.</li> <li> Minimum number of reviewers (usually 2) enforced for PR merges.</li> <li> Linters, code analyzers, and tests are required for PR merges.</li> <li> Quick review turnaround is enforced.</li> <li> See code review process.</li> </ul>"},{"location":"engineering-basic-checklist/#9-retrospectives","title":"9. Retrospectives","text":"<ul> <li> Retrospectives are held each sprint or week.</li> <li> 1-3 improvement experiments are identified and tracked.</li> <li> Experiments have owners and are added to the backlog.</li> <li> Longer retrospectives are held for milestones and project completion.</li> </ul>"},{"location":"engineering-basic-checklist/#10-engineering-feedback","title":"10. Engineering Feedback","text":"<ul> <li> Team submits feedback on blockers and improvements.</li> <li> Suggestions are incorporated into the solution.</li> <li> Feedback is detailed and actionable.</li> </ul>"},{"location":"engineering-basic-checklist/#11-developer-experience","title":"11. Developer Experience","text":"<p>Developers should be able to:</p> <ul> <li> Build/compile the source without errors.</li> <li> Run all automated tests (unit, integration, e2e).</li> <li> Start the solution end-to-end in a local or test environment.</li> <li> Debug the solution (set breakpoints, step through code, inspect variables).</li> <li> Use local development configuration (e.g., <code>.env</code>, <code>appsettings.development.json</code>).</li> </ul>"},{"location":"code-reviews/","title":"Code Reviews","text":""},{"location":"code-reviews/#introduction","title":"Introduction","text":"<p>Code review is a collaborative process where someone other than the author examines code changes before they are merged into a shared branch. The primary goals are to improve code quality, share knowledge, and maintain a healthy, maintainable codebase.</p>"},{"location":"code-reviews/#why-do-code-reviews","title":"Why Do Code Reviews?","text":"<ul> <li>Improve Code Quality: Identify and remove defects, enforce standards, and ensure best practices are followed before code is integrated.</li> <li>Knowledge Sharing: Expose team members to new patterns, technologies, and parts of the codebase, helping everyone learn and grow.</li> <li>Shared Understanding: Foster a shared understanding of the system and encourage collective ownership of the code.</li> </ul>"},{"location":"code-reviews/#what-to-look-for-in-a-code-review","title":"What to Look For in a Code Review","text":"<ul> <li>Design: Is the code well-designed and appropriate for the system?</li> <li>Functionality: Does the code behave as intended and meet requirements?</li> <li>Simplicity: Can the code be made simpler or more readable?</li> <li>Testing: Are there sufficient and effective automated tests?</li> <li>Naming: Are variable, class, and method names clear and meaningful?</li> <li>Comments: Are comments clear, necessary, and helpful?</li> <li>Style: Does the code follow the team's style guide?</li> <li>Documentation: Is relevant documentation updated as needed?</li> </ul>"},{"location":"code-reviews/#best-practices","title":"Best Practices","text":"<ul> <li>Review every pull request or change before merging.</li> <li>Choose reviewers who are familiar with the code or domain.</li> <li>Provide constructive, actionable feedback.</li> <li>Keep reviews timely and respectful.</li> <li>Use code review tools to streamline the process.</li> </ul>"},{"location":"code-reviews/#code-review-strategies","title":"Code Review Strategies","text":"<p>Different strategies can be used depending on the team, codebase, and experience level of contributors:</p> <ul> <li>Standard Pull Request Review: The most common approach. Code is reviewed by one or more team members before merging. Suitable for most changes and contributors.</li> <li>Pair Code Review (Recommended for Junior Developers): Junior developers are encouraged to review code together with a more experienced developer. This approach provides real-time feedback, learning opportunities, and helps juniors understand standards and best practices.</li> <li>Group Review: For complex or high-impact changes, a group review session can be held to gather feedback from multiple stakeholders at once.</li> <li>Self-Review: Authors should always review their own code before requesting a review, catching obvious issues early.</li> </ul> <p>Pair code review is especially valuable for onboarding, skill development, and ensuring that junior team members are supported in their growth.</p>"},{"location":"code-reviews/#resources-related-documentation","title":"Resources &amp; Related Documentation","text":"<ul> <li>Developer Code Review Guidance</li> <li>Reviewer Code Review Guidance</li> <li>Pull Request Template</li> <li>C# Code Review Checklist</li> <li>Bicep Code Review Checklist</li> </ul>"},{"location":"code-reviews/pull-request-template/","title":"Pull Request Template","text":"<pre><code>**Title:** `[Jira/Work Item ID]: Short summary of the change`\n\n## Overview\nSummarize what this pull request does and why these changes are needed.\n\n## Related Work\n- Link to Jira ticket(s), work item(s), or related issues.\n\n## Main Changes\n- Briefly outline the key changes, design decisions, or approaches taken.\n- If fixing a bug, describe the root cause and how it was resolved.\n\n## Validation\n- How was this tested? (unit/integration tests, manual steps, environments, etc.)\n- If applicable, provide steps to reproduce the issue and validate the fix.\n- Attach screenshots or logs if helpful.\n\n## Checklist\n- [ ] Code builds and tests pass\n- [ ] Meets style and linting standards\n- [ ] Documentation updated if needed\n- [ ] Linked to relevant work items\n- [ ] All feedback addressed\n- [ ] No sensitive data or secrets included\n\n## Breaking Changes\n- [ ] Yes\n- [ ] No\nIf yes, explain the impact and any migration steps required.\n\n## Additional Notes\n- Mention any follow-up work, known issues, or dependencies.\n</code></pre>"},{"location":"code-reviews/pull-requests/","title":"Pull Requests","text":""},{"location":"code-reviews/pull-requests/#what-is-a-pull-request","title":"What is a Pull Request?","text":"<p>A pull request (PR) is a request to merge code changes from one branch into another (typically into the main branch). PRs enable code inspection, automated checks, and collaborative review before changes are integrated into the main codebase.</p>"},{"location":"code-reviews/pull-requests/#general-process","title":"General Process","text":"<ol> <li>Implement changes based on clear requirements and acceptance criteria.</li> <li>Ensure code follows agreed conventions and passes all linters and tests.</li> <li>Update or add tests and documentation as needed.</li> <li>Create a pull request with a clear, descriptive title and detailed description.</li> <li>Request reviews from appropriate team members.</li> <li>Address feedback and update the PR as needed.</li> <li>Merge only after all checks and reviews are complete.</li> </ol>"},{"location":"code-reviews/pull-requests/#best-practices","title":"Best Practices","text":"<ul> <li>Keep PRs Small and Focused:<ul> <li>Small PRs are easier and faster to review, less likely to introduce bugs, and easier to merge.</li> <li>Each PR should address a single concern or feature.</li> </ul> </li> <li>Write Clear Titles and Descriptions:<ul> <li>Explain the \"what,\" \"why,\" and \"how\" of your changes.</li> <li>Reference related issues or tickets, but always provide context in the PR itself.</li> <li>Use a template for consistency (see below).</li> </ul> </li> <li>Include Related Tests:<ul> <li>Add or update tests to cover your changes.</li> <li>Describe how you tested the changes, especially for infrastructure or UI changes.</li> </ul> </li> <li>Follow Conventional Commits:<ul> <li>Use commit messages like <code>feat: add user authentication</code> or <code>fix(api): correct null reference bug</code>.</li> <li>See Conventional Commits for details.</li> </ul> </li> <li>Collaborate and Communicate:<ul> <li>Respond to feedback promptly and respectfully.</li> <li>Keep the PR up to date with the base branch as needed.</li> </ul> </li> <li>Don\u2019t Break the Build:<ul> <li>Ensure all checks pass before merging.</li> <li>Avoid merging large, risky, or untested changes.</li> </ul> </li> </ul>"},{"location":"code-reviews/pull-requests/#recommended-pull-request-template","title":"Recommended Pull Request Template","text":"<pre><code>## What?\nDescribe what changes are included in this PR.\n\n## Why?\nExplain the motivation or business/technical reason for these changes.\n\n## How?\nSummarize the approach, design decisions, or key implementation details.\n\n## Testing?\nDescribe how the changes were tested (include test coverage, manual steps, screenshots, etc.).\n\n## Anything Else?\nMention any follow-up work, known issues, or additional context.\n</code></pre>"},{"location":"code-reviews/pull-requests/#additional-tips","title":"Additional Tips","text":"<ul> <li>Use Conventional Commits for commit messages.</li> <li>Keep PRs self-contained and avoid mixing unrelated changes.</li> <li>Use screenshots or logs for UI or infrastructure changes when helpful.</li> </ul>"},{"location":"code-reviews/guidance/developer/","title":"Code Review Guidance for Developers (Authors)","text":""},{"location":"code-reviews/guidance/developer/#the-authors-role-and-mindset","title":"The Author's Role and Mindset","text":"<p>As a code author, your responsibility is to make your changes easy to review, understand, and integrate. Your goals are to:</p> <ul> <li>Deliver high-quality, maintainable code.</li> <li>Communicate intent and context clearly.</li> <li>Collaborate constructively with reviewers.</li> <li>Help keep the codebase healthy and consistent.</li> </ul>"},{"location":"code-reviews/guidance/developer/#best-practices-for-authors","title":"Best Practices for Authors","text":""},{"location":"code-reviews/guidance/developer/#1-prepare-your-change","title":"1. Prepare Your Change","text":"<ul> <li>Start with a clear goal: Know what problem you are solving and why.</li> <li>Keep changes small and focused: Submit self-contained changes that address a single concern. Avoid mixing unrelated changes.</li> <li>Write and update tests: Ensure new/changed code is covered by meaningful tests.</li> <li>Update documentation: Revise docs, comments, and READMEs as needed.</li> </ul>"},{"location":"code-reviews/guidance/developer/#2-write-a-great-pull-request-pr","title":"2. Write a Great Pull Request (PR)","text":"<ul> <li>Use a descriptive title: Start with the Jira ticket ID or work item ID, followed by a concise description of the change (e.g., <code>HMA-1234: Add authentication to login page</code>).</li> <li>Write a detailed description:<ul> <li>Explain what changed, why, and how.</li> <li>Reference related issues or tickets, but provide enough context in the PR itself.</li> <li>Use a checklist to clarify objectives and help reviewers focus on key areas.</li> </ul> </li> <li>Link work items: Connect the PR to relevant tasks, stories, or issues.</li> <li>Add reviewers: Request reviews from teammates familiar with the code or domain, and consider including someone less familiar for a fresh perspective.</li> <li>Annotate complex changes: Add comments in the code to explain non-obvious logic or design decisions. For large PRs, provide an overview or guide to help reviewers navigate the changes.</li> </ul>"},{"location":"code-reviews/guidance/developer/#3-before-requesting-review","title":"3. Before Requesting Review","text":"<ul> <li>Ensure code compiles and passes all tests.</li> <li>Run linters and style checks.</li> <li>Rebase or merge with the base branch to resolve conflicts.</li> <li>Double-check for secrets or sensitive data.</li> </ul>"},{"location":"code-reviews/guidance/developer/#handling-reviewer-comments-and-feedback","title":"Handling Reviewer Comments and Feedback","text":"<ul> <li>Be open to feedback: Respond to all comments respectfully and promptly.</li> <li>Address all feedback: Make changes as needed, or explain why a suggestion is not being adopted (with clear reasoning).</li> <li>Ask clarifying questions: If a comment is unclear, ask for more details in the review thread.</li> <li>Handle disagreements constructively: Discuss and reach consensus. If a discussion stalls, consider a quick meeting to resolve it.</li> <li>Create follow-up tasks: If a comment is out of scope, create a follow-up work item or issue.</li> </ul>"},{"location":"code-reviews/guidance/developer/#example-checklist-for-prs","title":"Example Checklist for PRs","text":"<pre><code>- [ ] Code compiles and passes all tests\n- [ ] Follows style and linting guidelines\n- [ ] PR description explains what, why, and how\n- [ ] Linked to relevant work items or issues\n- [ ] Added/updated tests and documentation\n- [ ] All comments addressed or explained\n</code></pre>"},{"location":"code-reviews/guidance/developer/#example-pr-description-template","title":"Example PR Description Template","text":"<pre><code>## What?\nDescribe what changes are included in this PR.\n\n## Why?\nExplain the motivation or business/technical reason for these changes.\n\n## How?\nSummarize the approach, design decisions, or key implementation details.\n\n## Testing?\nDescribe how the changes were tested (include test coverage, manual steps, screenshots, etc.).\n\n## Anything Else?\nMention any follow-up work, known issues, or additional context.\n</code></pre>"},{"location":"code-reviews/guidance/developer/#additional-tips","title":"Additional Tips","text":"<ul> <li>Use \"draft\" PRs for work in progress.</li> <li>If your PR is large, provide a guide or summary to help reviewers navigate it.</li> <li>Avoid force-pushing after review has started unless necessary\u2014communicate if you do.</li> <li>Thank reviewers for their time and feedback.</li> </ul>"},{"location":"code-reviews/guidance/reviewer/","title":"Code Review Guidance for Reviewers","text":""},{"location":"code-reviews/guidance/reviewer/#the-reviewers-role-and-mindset","title":"The Reviewer's Role and Mindset","text":"<p>As a reviewer, you are a steward of code quality, maintainability, and team growth. Your goal is to:</p> <ul> <li>Ensure code is correct, secure, and maintainable.</li> <li>Help authors grow and share knowledge.</li> <li>Keep the codebase healthy and consistent.</li> <li>Foster a positive, collaborative culture.</li> </ul>"},{"location":"code-reviews/guidance/reviewer/#what-to-look-for-in-a-code-review","title":"What to Look For in a Code Review","text":"<ol> <li>Design:<ul> <li>Is the code well-structured and appropriate for the system?</li> <li>Does it follow architectural patterns and design principles?</li> </ul> </li> <li>Functionality:<ul> <li>Does the code do what it\u2019s supposed to? Are requirements and acceptance criteria met?</li> <li>Are edge cases and error conditions handled?</li> </ul> </li> <li>Complexity and Readability:<ul> <li>Is the code as simple as possible? Can it be made clearer or more concise?</li> <li>Would another developer easily understand and maintain this code?</li> </ul> </li> <li>Testing:<ul> <li>Are there sufficient, effective automated tests (unit, integration, etc.)?</li> <li>Are tests meaningful and do they cover new/changed logic?</li> </ul> </li> <li>Naming:<ul> <li>Are variable, class, and method names clear, consistent, and meaningful?</li> </ul> </li> <li>Comments and Documentation:<ul> <li>Are comments clear, necessary, and helpful? Is documentation updated?</li> <li>Is the intent of complex code explained?</li> </ul> </li> <li>Style and Consistency:<ul> <li>Does the code follow the team\u2019s style guide and conventions?</li> <li>Is formatting consistent?</li> </ul> </li> <li>Security and Safety:<ul> <li>Are there any obvious security issues or unsafe practices?</li> <li>Is sensitive data handled appropriately?</li> </ul> </li> </ol>"},{"location":"code-reviews/guidance/reviewer/#how-to-review-effectively","title":"How to Review Effectively","text":""},{"location":"code-reviews/guidance/reviewer/#1-prepare-for-the-review","title":"1. Prepare for the Review","text":"<ul> <li>Read the PR description and related work items for context.</li> <li>Skim the overall change before diving into details.</li> </ul>"},{"location":"code-reviews/guidance/reviewer/#2-review-thoroughly-prioritizing-major-issues","title":"2. Review Thoroughly, Prioritizing Major Issues","text":"<ul> <li>Focus first on correctness, security, and design.</li> <li>Group minor issues (style, nits) and suggest fixes, but don\u2019t block on them unless they are pervasive.</li> </ul>"},{"location":"code-reviews/guidance/reviewer/#3-give-respectful-actionable-feedback","title":"3. Give Respectful, Actionable Feedback","text":"<ul> <li>Phrase feedback as suggestions, not commands (e.g., \"Consider renaming...\" or \"Could we simplify this by...\").</li> <li>Be specific about what needs to change and why.</li> <li>Suggest alternatives or improvements when possible.</li> <li>Focus on the code, not the person.</li> </ul>"},{"location":"code-reviews/guidance/reviewer/#example-of-good-feedback","title":"Example of Good Feedback:","text":"<p>Consider extracting this logic into a helper method to improve readability and reduce duplication.</p>"},{"location":"code-reviews/guidance/reviewer/#example-of-poor-feedback","title":"Example of Poor Feedback:","text":"<p>This is wrong. Fix it.</p>"},{"location":"code-reviews/guidance/reviewer/#4-handle-disagreements-and-pushback","title":"4. Handle Disagreements and Pushback","text":"<ul> <li>Distinguish between required changes and optional suggestions (e.g., use \"nit:\" for non-blocking comments).</li> <li>If you disagree, explain your reasoning and be open to discussion.</li> <li>If consensus cannot be reached, escalate respectfully (e.g., involve a tech lead).</li> </ul>"},{"location":"code-reviews/guidance/reviewer/#5-review-promptly-and-communicate","title":"5. Review Promptly and Communicate","text":"<ul> <li>Respond to review requests in a timely manner (ideally within one business day).</li> <li>If you need more time, let the author know.</li> <li>Don\u2019t let reviews block the team\u2019s progress.</li> </ul>"},{"location":"code-reviews/guidance/reviewer/#6-encourage-learning-and-growth","title":"6. Encourage Learning and Growth","text":"<ul> <li>Use reviews as opportunities for mentoring and knowledge sharing.</li> <li>Recognize good work and improvements.</li> </ul>"},{"location":"code-reviews/guidance/reviewer/#the-review-process-step-by-step","title":"The Review Process: Step-by-Step","text":"<ol> <li>Read the PR description and related context.</li> <li>Skim the diff to get a sense of the change.</li> <li>Review each file, leaving comments and questions as needed.</li> <li>Summarize your feedback and next steps (approve, request changes, or ask questions).</li> <li>Follow up on responses and re-reviews until the PR is ready to merge.</li> </ol>"},{"location":"code-reviews/guidance/reviewer/#example-reviewer-checklist","title":"Example Reviewer Checklist","text":"<pre><code>- [ ] Code meets requirements and acceptance criteria\n- [ ] No obvious bugs, security, or performance issues\n- [ ] Code is clear, maintainable, and well-structured\n- [ ] Tests are adequate, meaningful, and passing\n- [ ] Documentation and comments are updated if needed\n- [ ] Feedback is constructive, actionable, and respectful\n- [ ] Review completed promptly and communicated clearly\n</code></pre>"},{"location":"code-reviews/guidance/reviewer/#additional-tips","title":"Additional Tips","text":"<ul> <li>Use \"Approve\" when the code is ready to merge, \"Request changes\" for blocking issues, and \"Comment\" for questions or suggestions.</li> <li>Use \"nit:\" for minor, non-blocking suggestions.</li> <li>If a PR is too large, ask the author to split it into smaller, focused changes.</li> <li>Praise good practices and improvements to encourage positive behavior.</li> </ul>"},{"location":"code-reviews/recipes/bicep/","title":"Bicep Code Review Guidance","text":""},{"location":"code-reviews/recipes/bicep/#style-guide","title":"Style Guide","text":""},{"location":"code-reviews/recipes/bicep/#bicep-coding-conventions","title":"Bicep Coding Conventions","text":"<ul> <li>Naming:<ul> <li>Use descriptive, meaningful names for resources, parameters, and variables.</li> <li>Use camelCase for variables and parameters, and PascalCase for resource names.</li> </ul> </li> <li>Layout and Structure:<ul> <li>Organize code logically: parameters, variables, resources, outputs.</li> <li>Use comments to explain complex logic or intent.</li> <li>Group related resources together.</li> </ul> </li> <li>Parameters and Variables:<ul> <li>Use parameters for values that may change between deployments.</li> <li>Set default values and use allowed values where appropriate.</li> <li>Use variables to simplify complex expressions.</li> </ul> </li> <li>Resource Definitions:<ul> <li>Use symbolic names for resources.</li> <li>Reference outputs and properties using symbolic names, not hardcoded strings.</li> <li>Use modules to encapsulate reusable components.</li> </ul> </li> <li>Outputs:<ul> <li>Output important resource IDs, endpoints, or connection strings as needed.</li> </ul> </li> </ul>"},{"location":"code-reviews/recipes/bicep/#secure-bicep-practices","title":"Secure Bicep Practices","text":"<ul> <li>Input Validation:<ul> <li>Use allowed values and constraints for parameters.</li> <li>Avoid using overly permissive values (e.g., 0.0.0.0/0 for IP ranges).</li> </ul> </li> <li>Secrets Management:<ul> <li>Never hardcode secrets or credentials in Bicep files.</li> <li>Use Azure Key Vault references for sensitive data.</li> </ul> </li> <li>Access Control:<ul> <li>Apply least privilege to role assignments and access policies.</li> <li>Use managed identities where possible.</li> </ul> </li> <li>Resource Security:<ul> <li>Enable diagnostic logging and monitoring for resources.</li> <li>Use secure defaults (e.g., HTTPS only, encryption at rest).</li> </ul> </li> <li>General Security:<ul> <li>Keep modules and referenced templates up to date.</li> <li>Review and test templates for security vulnerabilities.</li> <li>Use template validation tools (e.g., <code>bicep build</code>, <code>bicep linter</code>).</li> </ul> </li> </ul>"},{"location":"code-reviews/recipes/bicep/#code-analysis-linting","title":"Code Analysis / Linting","text":"<ul> <li>Use the Bicep linter to enforce style and best practices (<code>bicep build</code> and <code>bicep lint</code>).</li> <li>Address all warnings and errors before merging code.</li> </ul>"},{"location":"code-reviews/recipes/bicep/#build-validation","title":"Build Validation","text":"<ul> <li>Validate Bicep files in CI pipelines to prevent deployment of invalid or insecure templates.</li> <li>Use test deployments or what-if analysis to verify changes.</li> </ul>"},{"location":"code-reviews/recipes/bicep/#code-review-checklist","title":"Code Review Checklist","text":"<p>In addition to general code review best practices, consider the following Bicep-specific items:</p> <ul> <li>Are resource names, parameters, and variables clear and consistent?</li> <li>Are parameters validated with allowed values and constraints?</li> <li>Are secrets and sensitive data handled securely?</li> <li>Is least privilege applied to all access controls?</li> <li>Are modules used for reusable components?</li> <li>Are outputs meaningful and necessary?</li> <li>Are all linter warnings and errors addressed?</li> <li>Is the template free of hardcoded values that should be parameterized?</li> <li>Are secure defaults enforced for all resources?</li> <li>Is diagnostic logging enabled where appropriate?</li> <li>Are dependencies and references up to date?</li> </ul>"},{"location":"code-reviews/recipes/csharp/","title":"C# Code Review Guidance","text":""},{"location":"code-reviews/recipes/csharp/#style-guide","title":"Style Guide","text":""},{"location":"code-reviews/recipes/csharp/#c-coding-conventions","title":"C# Coding Conventions","text":"<ul> <li>Naming:<ul> <li>Use PascalCase for class, method, and property names.</li> <li>Use camelCase for local variables and method parameters.</li> <li>Use ALL_CAPS for constants.</li> <li>Prefix interfaces with 'I' (e.g., <code>IService</code>).</li> </ul> </li> <li>Layout and Spacing:<ul> <li>Use four spaces per indentation level (no tabs).</li> <li>Place opening braces on a new line for types and methods; same line for other blocks.</li> <li>Use a single blank line to separate logically related code blocks.</li> </ul> </li> <li>Modifiers and Visibility:<ul> <li>Order elements: public, protected, internal, private.</li> <li>Use explicit access modifiers.</li> </ul> </li> <li>Expression and Statement Formatting:<ul> <li>Use <code>var</code> when the type is obvious; otherwise, use explicit types.</li> <li>Use object and collection initializers where possible.</li> <li>Prefer string interpolation over string.Format or concatenation.</li> </ul> </li> <li>Other Best Practices:<ul> <li>Use properties instead of public fields.</li> <li>Use using statements for resource management.</li> <li>Avoid magic numbers; use named constants or enums.</li> <li>Comment code where necessary, but prefer self-explanatory code.</li> </ul> </li> </ul>"},{"location":"code-reviews/recipes/csharp/#secure-coding-guidelines","title":"Secure Coding Guidelines","text":"<ul> <li>Input Validation:<ul> <li>Always validate and sanitize user input.</li> <li>Use parameterized queries to prevent SQL injection.</li> </ul> </li> <li>Authentication and Authorization:<ul> <li>Use strong authentication mechanisms.</li> <li>Enforce least privilege for users and services.</li> </ul> </li> <li>Error Handling:<ul> <li>Do not expose sensitive information in error messages.</li> <li>Log exceptions securely; avoid logging secrets.</li> </ul> </li> <li>Data Protection:<ul> <li>Use encryption for sensitive data at rest and in transit.</li> <li>Store secrets in secure locations (e.g., Azure Key Vault).</li> </ul> </li> <li>Code Practices:<ul> <li>Avoid hardcoding credentials or secrets.</li> <li>Use secure libraries and frameworks.</li> <li>Keep dependencies up to date.</li> </ul> </li> <li>Other Security Practices:<ul> <li>Use secure defaults.</li> <li>Regularly review and test for vulnerabilities.</li> <li>Apply security patches promptly.</li> </ul> </li> </ul>"},{"location":"code-reviews/recipes/csharp/#code-analysis-linting","title":"Code Analysis / Linting","text":"<ul> <li>Use analyzers and linters to enforce style and code quality rules.</li> <li>Recommended packages:<ul> <li><code>Microsoft.CodeAnalysis.NetAnalyzers</code></li> <li><code>StyleCop.Analyzers</code></li> </ul> </li> <li>Use a shared <code>common.props</code> file and reference it in all projects for consistent configuration.</li> <li>Use <code>.editorconfig</code> to customize and override rules as needed.</li> <li>Adopt the Managed Recommended Rules as a minimum rule set.</li> </ul>"},{"location":"code-reviews/recipes/csharp/#automatic-code-formatting","title":"Automatic Code Formatting","text":"<ul> <li>Configure code formatting rules in <code>.editorconfig</code>.</li> <li>Use IDE or command-line tools to auto-format code before committing.</li> </ul>"},{"location":"code-reviews/recipes/csharp/#build-validation","title":"Build Validation","text":"<ul> <li>Enforce code style and rules in CI pipelines to prevent non-compliant code from being merged.</li> <li>Ensure analyzers and StyleCop run as part of the build process.</li> </ul>"},{"location":"code-reviews/recipes/csharp/#enable-roslyn-support-in-vs-code","title":"Enable Roslyn Support in VS Code","text":"<ul> <li>Set <code>omnisharp.enableRoslynAnalyzers</code> to <code>true</code> in VS Code settings.</li> <li>Restart Omnisharp or VS Code after changing this setting.</li> </ul>"},{"location":"code-reviews/recipes/csharp/#code-review-checklist","title":"Code Review Checklist","text":"<p>In addition to general code review best practices, consider the following C#-specific items:</p> <ul> <li>Correct use of asynchronous programming (<code>async</code>/<code>await</code>, <code>Task.WhenAll</code>, <code>CancellationToken</code>)</li> <li>Concurrency: Are shared objects properly protected?</li> <li>Dependency Injection (DI): Is it used and set up correctly?</li> <li>Middleware: Is it configured properly?</li> <li>Deterministic resource release: Use <code>IDisposable</code> and the <code>using</code> pattern</li> <li>Avoid excessive short-lived objects and unnecessary boxing</li> <li>Proper exception handling: Catch specific exceptions, not just <code>Exception</code></li> <li>Use NuGet for package management, not committed DLLs</li> <li>Appropriate use of LINQ</li> <li>Argument validation (e.g., CA1062)</li> <li>Telemetry: Are metrics, tracing, and logging instrumented?</li> <li>Use the options design pattern for configuration</li> <li>Use constants/static classes for repeated strings</li> <li>Avoid magic numbers; use constants or enums</li> <li>Tests: Use Arrange/Act/Assert pattern and document accordingly</li> <li>Async method names should end with <code>Async</code></li> <li>Use <code>Task.Delay</code> instead of <code>Thread.Sleep</code> in async methods</li> <li>Use cancellation tokens for async tasks</li> <li>Ensure sensible logging levels and minimum logging is in place</li> <li>Use correct access modifiers (internal, private, public)</li> <li>Use auto-properties appropriately</li> <li>Ensure thread safety for in-memory collections</li> </ul>"},{"location":"dev-sec-ops/secret-scanning/","title":"Secret Scanning and Credential Management","text":"<p>To protect sensitive information and maintain compliance, all projects must ensure that secrets (such as API keys, passwords, tokens, and certificates) are never committed to source control.</p>"},{"location":"dev-sec-ops/secret-scanning/#why-secret-scanning","title":"Why Secret Scanning?","text":"<ul> <li>Prevents accidental exposure of credentials and secrets.</li> <li>Reduces risk of security breaches and data leaks.</li> <li>Supports compliance with industry standards and regulations.</li> </ul>"},{"location":"dev-sec-ops/secret-scanning/#best-practices","title":"Best Practices","text":"<ul> <li>Never store secrets in code repositories.</li> <li>Use environment variables or secure vaults (e.g., Azure Key Vault, AWS Secrets Manager) for secret management.</li> <li>Rotate secrets regularly and immediately after exposure.</li> <li>Review and remove secrets from commit history if found.</li> </ul>"},{"location":"dev-sec-ops/secret-scanning/#automated-secret-scanning","title":"Automated Secret Scanning","text":"<p>Use automated tools to scan for secrets before code is pushed or merged: - GitHub Advanced Security: Built-in secret scanning for public and private repos. - TruffleHog: Scans git history for secrets. - Gitleaks: Detects hardcoded secrets in code and git history. - Pre-commit hooks: Integrate secret scanning into your CI/CD pipeline.</p>"},{"location":"dev-sec-ops/secret-scanning/#responding-to-exposed-secrets","title":"Responding to Exposed Secrets","text":"<ol> <li>Revoke the exposed secret immediately.</li> <li>Remove the secret from all code and commit history.</li> <li>Rotate the secret and update all dependent systems.</li> <li>Notify your security team and follow incident response procedures.</li> </ol> <p>For more on secure development, see the Security Guide.</p>"},{"location":"dev-sec-ops/static-code-analysis/","title":"Static Code Analysis","text":"<p>Static code analysis is a critical practice for identifying bugs, vulnerabilities, and code quality issues early in the development lifecycle before code is deployed.</p>"},{"location":"dev-sec-ops/static-code-analysis/#why-static-code-analysis","title":"Why Static Code Analysis?","text":"<ul> <li>Detects security vulnerabilities, code smells, and bugs automatically.</li> <li>Enforces coding standards and best practices.</li> <li>Improves maintainability and reliability of codebases.</li> <li>Reduces technical debt and review effort.</li> </ul>"},{"location":"dev-sec-ops/static-code-analysis/#recommended-tools","title":"Recommended Tools","text":""},{"location":"dev-sec-ops/static-code-analysis/#sonarcloud-cloud-based","title":"SonarCloud (Cloud-Based)","text":"<ul> <li>SaaS solution for static code analysis.</li> <li>Integrates with GitHub, Azure DevOps, Bitbucket, and more.</li> <li>Provides dashboards, pull request decoration, and quality gates.</li> <li>Recommended for public or cloud-hosted projects.</li> <li>SonarCloud Documentation</li> </ul>"},{"location":"dev-sec-ops/static-code-analysis/#sonarqube-community-edition-on-premises","title":"SonarQube Community Edition (On-Premises)","text":"<ul> <li>Free, open-source version of SonarQube for on-premises deployment.</li> <li>Suitable for private networks and regulated environments.</li> <li>Can be deployed within your organization's infrastructure for full control.</li> <li>Integrates with CI/CD pipelines and supports multiple languages.</li> <li>SonarQube Community Edition Docs</li> </ul>"},{"location":"dev-sec-ops/static-code-analysis/#ide-plugins","title":"IDE Plugins","text":"<ul> <li>SonarLint: Real-time feedback in IDEs (VS Code, IntelliJ, Eclipse, etc.).</li> <li>Helps developers catch issues before code is committed.</li> <li>SonarLint Documentation</li> </ul>"},{"location":"dev-sec-ops/static-code-analysis/#best-practices","title":"Best Practices","text":"<ul> <li>Integrate static analysis into CI pipelines to block merging code with critical issues.</li> <li>Use quality gates to enforce minimum standards (e.g., no new critical bugs or vulnerabilities).</li> <li>Run analysis on all pull requests and main branches.</li> <li>Use IDE plugins for immediate feedback during development.</li> <li>Regularly review and address issues flagged by the tools.</li> </ul> <p>For more on secure development, see the Security Guide.</p>"},{"location":"source-control/","title":"Source Control Overview: Git, Git Flow &amp; GitHub Flow","text":"<p>Effective source control is essential for collaboration, code quality, and project stability. NCS internal and client projects use Git as the version control system, and adopt either the Git Flow or GitHub Flow branching models depending on project needs.</p>"},{"location":"source-control/#why-git","title":"Why Git?","text":"<p>Git is a distributed version control system that enables teams to track changes, collaborate efficiently, and maintain a complete history of the codebase. It is the industry standard for modern software development.</p>"},{"location":"source-control/#branching-strategies","title":"Branching Strategies","text":""},{"location":"source-control/#git-flow","title":"Git Flow","text":"<p>Git Flow is a robust branching strategy ideal for projects with scheduled releases and multiple environments (e.g., development, staging, production). It defines clear roles for different branches:</p> <ul> <li>main: Always production-ready; contains the latest release.</li> <li>develop: Integration branch for features; reflects the latest development changes.</li> <li>feature/: Used for new features; branched from <code>develop</code>.</li> <li>bugfix/: Used for bug fixes; branched from <code>develop</code>.</li> <li>release/: Prepares for a new production release; branched from <code>develop</code>.</li> <li>hotfix/: Urgent fixes for production; branched from <code>main</code>.</li> </ul> <p>All changes are made in branches and merged via pull requests. Direct commits to <code>main</code> or <code>develop</code> are not allowed.</p> <p>Diagram:</p> <pre><code>flowchart LR\n    A[main] ---|branch| B[hotfix/x]\n    A ---|branch| C[release/x]\n    C ---|merge| A\n    D[develop] ---|branch| E[feature/x]\n    D ---|branch| F[bugfix/x]\n    E ---|merge| D\n    F ---|merge| D\n    D ---|merge| C\n    C ---|merge| D\n    A ---|merge| D</code></pre>"},{"location":"source-control/#github-flow","title":"GitHub Flow","text":"<p>GitHub Flow is a simpler, more lightweight workflow, best suited for projects with continuous delivery and frequent deployments. It uses only a single long-lived branch (<code>main</code> or <code>master</code>) and short-lived feature branches:</p> <ul> <li>main: Always deployable; all changes are merged here.</li> <li>feature/: Created from <code>main</code> for new work (features, fixes, etc.).</li> </ul> <p>Workflow: 1. Create a branch from <code>main</code> for your work. 2. Open a pull request early for feedback and CI. 3. Merge into <code>main</code> after review and successful tests. 4. Deploy from <code>main</code>.</p> <p>Diagram:</p> <pre><code>flowchart LR\n    A[main] ---|branch| B[feature/x]\n    B ---|pull request| A\n    A ---|deploy| D[Production]</code></pre>"},{"location":"source-control/#comparison-git-flow-vs-github-flow","title":"Comparison: Git Flow vs GitHub Flow","text":"Aspect Git Flow GitHub Flow Complexity Higher (multiple long-lived branches) Simpler (single long-lived branch) Release Model Scheduled, versioned releases Continuous delivery Environments Supports multiple (dev, staging, prod) Typically single (prod) Branch Types main, develop, feature, release, hotfix, bugfix main, feature Use Case Enterprise, regulated, or complex projects Startups, open source, fast delivery Merge Strategy PRs to develop/main, release/hotfix branches PRs to main only"},{"location":"source-control/#key-practices","title":"Key Practices","text":"<ul> <li>Use branching.md for branch types, naming, and workflow</li> <li>Follow versioning.md for semantic versioning and tagging</li> <li>Use merge-strategies.md for pull request and merge best practices</li> </ul> <p>For details on each topic, see the linked documents above. Adhering to these practices ensures a clean, maintainable, and collaborative codebase.</p>"},{"location":"source-control/branching/","title":"Git Branching Strategies","text":"<p>NCS projects use either Git Flow or GitHub Flow depending on project requirements. This guide details both approaches, including branch types, workflows, and naming conventions.</p>"},{"location":"source-control/branching/#git-flow","title":"Git Flow","text":"<p>Git Flow is suited for projects with scheduled releases and multiple environments. It uses several long-lived and short-lived branches:</p>"},{"location":"source-control/branching/#branch-types","title":"Branch Types","text":"<ul> <li>main: Always deployable, production-ready code.</li> <li>develop: Integration branch for features; stable but not always production-ready.</li> <li>feature/xxx: For new features (e.g., <code>feature/login-page</code>).</li> <li>bugfix/xxx: For bug fixes (e.g., <code>bugfix/login-error</code>).</li> <li>release/xxx: For preparing a release (e.g., <code>release/1.2.0</code>).</li> <li>hotfix/xxx: For urgent fixes to production (e.g., <code>hotfix/critical-crash</code>).</li> </ul>"},{"location":"source-control/branching/#workflow","title":"Workflow","text":"<ol> <li>Create a <code>feature/</code> or <code>bugfix/</code> branch from <code>develop</code>.</li> <li>Merge feature/bugfix into <code>develop</code> via pull request.</li> <li>When ready to release, create a <code>release/</code> branch from <code>develop</code>.</li> <li>Finalize and test in <code>release/</code>, then merge into both <code>main</code> and <code>develop</code>.</li> <li>Tag the release on <code>main</code>.</li> <li>For urgent production fixes, create a <code>hotfix/</code> branch from <code>main</code>, then merge into both <code>main</code> and <code>develop</code>.</li> </ol>"},{"location":"source-control/branching/#diagram","title":"Diagram","text":"<pre><code>flowchart LR\n    main ---|branch| hotfix[hotfix/x]\n    main ---|branch| release[release/x]\n    release ---|merge| main\n    develop ---|branch| feature[feature/x]\n    develop ---|branch| bugfix[bugfix/x]\n    feature ---|merge| develop\n    bugfix ---|merge| develop\n    develop ---|merge| release\n    release ---|merge| develop\n    hotfix ---|merge| main\n    hotfix ---|merge| develop</code></pre>"},{"location":"source-control/branching/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Use lowercase, hyphen-separated names for clarity (e.g., <code>feature/user-login</code>).</li> <li>Prefix with type: <code>feature/</code>, <code>bugfix/</code>, <code>release/</code>, <code>hotfix/</code>.</li> </ul>"},{"location":"source-control/branching/#github-flow","title":"GitHub Flow","text":"<p>GitHub Flow is a lightweight workflow ideal for continuous delivery and frequent deployments. It uses a single long-lived branch and short-lived feature branches.</p>"},{"location":"source-control/branching/#branch-types_1","title":"Branch Types","text":"<ul> <li>main: Always deployable, production-ready code.</li> <li>feature/xxx: For new work (features, fixes, etc.), branched from <code>main</code> (e.g., <code>feature/login-page</code>).</li> </ul>"},{"location":"source-control/branching/#workflow_1","title":"Workflow","text":"<ol> <li>Create a <code>feature/</code> branch from <code>main</code> for your work.</li> <li>Commit and push changes to the feature branch.</li> <li>Open a pull request early for feedback and CI.</li> <li>After review and successful tests, merge into <code>main</code>.</li> <li>Deploy from <code>main</code>.</li> </ol>"},{"location":"source-control/branching/#diagram_1","title":"Diagram","text":"<pre><code>flowchart LR\n    main ---|branch| feature[feature/x]\n    feature ---|pull request| main\n    main ---|deploy| prod[Production]</code></pre>"},{"location":"source-control/branching/#naming-conventions_1","title":"Naming Conventions","text":"<ul> <li>Use lowercase, hyphen-separated names for clarity (e.g., <code>feature/user-login</code>).</li> <li>Prefix with <code>feature/</code> for all new work.</li> </ul>"},{"location":"source-control/branching/#choosing-a-strategy","title":"Choosing a Strategy","text":"<ul> <li>Use Git Flow for complex projects with multiple environments and scheduled releases.</li> <li>Use GitHub Flow for projects with continuous delivery and frequent deployments.</li> </ul> <p>For more on workflow, see merge-strategies.md and versioning.md.</p>"},{"location":"source-control/merge-strategies/","title":"Merge Strategies: Git Flow &amp; GitHub Flow","text":"<p>This guide covers recommended merge strategies for both Git Flow and GitHub Flow workflows.</p>"},{"location":"source-control/merge-strategies/#git-flow-merge-strategies","title":"Git Flow Merge Strategies","text":"<ul> <li>Pull Requests (PRs): All changes are merged via PRs for review and traceability.</li> <li>Feature/Bugfix Branches:<ul> <li>Merge into <code>develop</code> using Squash and Merge for a clean, linear history.</li> <li>Use Merge Commit if you need to preserve the full branch history (less common).</li> </ul> </li> <li>Release/Hotfix Branches:<ul> <li>Merge into both <code>main</code> and <code>develop</code> using Merge Commit to preserve context.</li> </ul> </li> <li>No direct commits to <code>main</code> or <code>develop</code>.</li> <li>Always resolve conflicts before merging.</li> </ul> <p>Diagram: <pre><code>flowchart LR\n        feature[feature/x] -- PR --&gt; develop\n        bugfix[bugfix/x] -- PR --&gt; develop\n        develop -- PR (release) --&gt; release[release/x]\n        release -- PR --&gt; main\n        release -- PR --&gt; develop\n        hotfix[hotfix/x] -- PR --&gt; main\n        hotfix -- PR --&gt; develop</code></pre></p>"},{"location":"source-control/merge-strategies/#github-flow-merge-strategies","title":"GitHub Flow Merge Strategies","text":"<ul> <li>Pull Requests (PRs): All changes are merged via PRs for review and CI.</li> <li>Feature Branches:<ul> <li>Merge into <code>main</code> using Squash and Merge (recommended for a simple, linear history).</li> <li>Use Rebase and Merge if you want to keep a flat history and have rebased locally.</li> </ul> </li> <li>No direct commits to <code>main</code>.</li> <li>Always resolve conflicts before merging.</li> </ul> <p>Diagram: <pre><code>flowchart LR\n        feature[feature/x] -- PR --&gt; main\n        main -- deploy --&gt; prod[Production]</code></pre></p>"},{"location":"source-control/merge-strategies/#choosing-a-merge-strategy","title":"Choosing a Merge Strategy","text":"<ul> <li>Squash and Merge: Default for most PRs; creates a single commit for the branch.</li> <li>Merge Commit: Use for release/hotfix branches in Git Flow, or when you need to preserve all commits.</li> <li>Rebase and Merge: Use with caution; only after rebasing locally and ensuring a clean history.</li> </ul>"},{"location":"source-control/merge-strategies/#using-cherry-pick","title":"Using Cherry-Pick","text":"<p>While not required for standard Git Flow or GitHub Flow, <code>git cherry-pick</code> is useful for selectively applying specific commits from one branch to another. Common scenarios include:</p> <ul> <li>Backporting fixes: Apply a bug fix from <code>develop</code> or <code>main</code> to a <code>hotfix/</code> or <code>release/</code> branch without merging unrelated changes.</li> <li>Selective updates: Move a single feature or fix to another branch when a full merge is not appropriate.</li> </ul> <p>Best Practices: - Use cherry-pick sparingly; prefer merges and pull requests for regular workflows. - Always test after cherry-picking to ensure no conflicts or regressions. - Document cherry-picked commits in pull requests or changelogs for traceability.</p> <p>Example:</p> <pre><code># Cherry-pick a commit from develop to hotfix branch\ngit checkout hotfix/1.2.1\ngit cherry-pick &lt;commit-hash&gt;\n</code></pre> <p>For more, see Git documentation on cherry-pick.</p>"},{"location":"source-control/versioning/","title":"Versioning Strategy: Git Flow &amp; GitHub Flow","text":"<p>This guide explains how versioning is managed in both Git Flow and GitHub Flow workflows.</p>"},{"location":"source-control/versioning/#semantic-versioning-semver","title":"Semantic Versioning (SemVer)","text":"<p>All projects use Semantic Versioning:</p> <p><code>MAJOR.MINOR.PATCH</code> (e.g., <code>1.2.3</code>)</p> <ul> <li>MAJOR: Incompatible API changes</li> <li>MINOR: Backwards-compatible new features</li> <li>PATCH: Backwards-compatible bug fixes</li> </ul>"},{"location":"source-control/versioning/#git-flow-versioning","title":"Git Flow Versioning","text":"<ul> <li>Releases are prepared in <code>release/</code> branches.</li> <li>When ready, merge <code>release/</code> into <code>main</code> and tag the release (e.g., <code>v1.2.3</code>).</li> <li>Hotfixes are tagged after merging <code>hotfix/</code> into <code>main</code>.</li> <li>Maintain a <code>CHANGELOG.md</code> to document changes for each release.</li> </ul> <p>Diagram: <pre><code>flowchart LR\n  develop -- branch --&gt; release[release/1.2.0]\n  release -- merge &amp; tag v1.2.0 --&gt; main\n  main -- tag v1.2.0 --&gt; tag1((v1.2.0))\n  main -- branch --&gt; hotfix[hotfix/1.2.1]\n  hotfix -- merge &amp; tag v1.2.1 --&gt; main\n  main -- tag v1.2.1 --&gt; tag2((v1.2.1))</code></pre></p>"},{"location":"source-control/versioning/#github-flow-versioning","title":"GitHub Flow Versioning","text":"<ul> <li>All changes are merged into <code>main</code>.</li> <li>Tag releases on <code>main</code> when deploying to production (e.g., <code>v1.2.3</code>).</li> <li>Use a <code>CHANGELOG.md</code> to track notable changes.</li> </ul> <p>Diagram: <pre><code>flowchart LR\n  main -- merge --&gt; main\n  main -- tag v1.2.0 --&gt; tag1((v1.2.0))\n  main -- tag v1.2.1 --&gt; tag2((v1.2.1))</code></pre></p>"},{"location":"source-control/versioning/#best-practices","title":"Best Practices","text":"<ul> <li>Tag every production release with a semantic version.</li> <li>Keep <code>CHANGELOG.md</code> up to date.</li> <li>Use pre-release tags (e.g., <code>v1.2.0-beta</code>) for testing.</li> </ul> <p>For more, see branching.md and merge-strategies.md.</p>"},{"location":"week-one/","title":"The First Week of an Engineering Project","text":"<p>The purpose of this document is to:</p> <ul> <li>Organize content in the playbook for quick reference and discoverability</li> <li>Provide content in a logical structure which reflects the engineering process</li> <li>Extensible hierarchy to allow teams to share deep subject-matter expertise</li> <li></li> </ul>"},{"location":"week-one/#before-starting-the-project","title":"Before Starting the Project","text":""},{"location":"week-one/#day-1","title":"Day 1","text":""},{"location":"week-one/#day-2","title":"Day 2","text":""},{"location":"week-one/#day-3","title":"Day 3","text":""},{"location":"week-one/#day-4","title":"Day 4","text":""},{"location":"week-one/#day-5","title":"Day 5","text":""}]}